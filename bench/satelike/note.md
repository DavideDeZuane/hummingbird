# SATELIKE


Aggiungere la parte di payload totale in modo nel caso in cui si fa uso della frammentazione
quanto è l'overhead introdotto a causa degli header aggiuntivi


## Configuration 1

rappresentano il tempo di CPU consumato dal container espresso in "nanosecondi"
Whit the configuration 1 of strongswan, the initiator has the following resource usage at rest:

```
memory: 3.8 MB
```

The loaded plugins are the following:

```
loaded plugins: charon random nonce x509 revocation constraints pubkey pkcs1 pkcs7 pgp dnskey sshkey pem openssl pkcs8 xcbc cmac kdf ml drbg curl attr kernel-netlink resolve socket-default vici updown xauth-generic counters

```


While during the negotiation we have that:

```
CPU units: 
```


## Configuration 2 

Whit the configuration 2 of strongswan, the resources usage at rest:

```
memory: 3.6 MB
```

The loaded plugins are:

```
loaded plugins: charon random nonce openssl pem pkcs1 curl vici kernel-netlink socket-default updown pubkey save-keys ml

```


So we can see that the cpu usage is more intensive in the first configuration.



Pacchetti python da installare 

```
scapy
docker
pycryptodome
pyshark
```

## ML-KEM

`strongswan/src/libcharon/sa/ikev2/tasks/ike_init.c` a questo file si fa il parsing dei payload e qui si fa il get_key_exchange_method e inoltre è presente la funzione determinate_key_exchanges
ed è presente la funzione create_ke che richiama libcrypto


La definizione di create_ke è in strongswan/src/libcharon/sa/keymat.h

Il set e get delle chiavi per il key exchange sono in `strongswan/src/libstrongswan/crypto/key_exchange.h`

```
/**
 * Implementation of a key exchange algorithm or a key encapsulation mechanism
 * (KEM).
 *
 * For KEMs, implementations can assume the following order of method calls
 * on initiator and responder, which allows them to determine their role:
   @verbatim
 Initiator                  Responder
 get_public_key()
                            set_public_key()
                            get_public_key()
 set_public_key()
 get_shared_secret()
                            get_shared_secret()
   @endverbatim
 * Initiators are expected to return the public key of a randomly generated
 * key pair from get_public_key(). Responders will receive that via
 * set_public_key() and encapsulate a randomly generated shared secret with it.
 * The resulting ciphertext is expected to be returned by the responder from
 * get_public_key(). It gets passed to the initiator via set_public_key(), which
 * decapsulates it using its private key to get the shared secret generated by
 * the responder.
 */
struct key_exchange_t {

	/**
	 * Returns the shared secret of this key exchange method.
	 *
	 * @param secret	shared secret (allocated)
	 * @return			TRUE if shared secret computed successfully
	 */
	bool (*get_shared_secret)(key_exchange_t *this, chunk_t *secret)
		__attribute__((warn_unused_result));

	/**
	 * Sets the public key received from the peer.
	 *
	 * See the interface description on how this method is used with KEMs.
	 *
	 * @note This operation should be relatively quick. Costly public key
	 * validation operations or key derivation should be implemented in
	 * get_shared_secret(). For KEMs that's not possible, however, it's also
	 * not as important because they usually won't be used as initial key
	 * exchange method during IKE_SA_INIT.
	 *
	 * @param value		public key of peer
	 * @return			TRUE if other public key verified and set
	 */
	bool (*set_public_key)(key_exchange_t *this, chunk_t value)
		__attribute__((warn_unused_result));

	/**
	 * Gets the own public key to transmit.
	 *
	 * See the interface description on how this method is used with KEMs.
	 *
	 * @param value		public key (allocated)
	 * @return			TRUE if public key retrieved
	 */
	bool (*get_public_key)(key_exchange_t *this, chunk_t *value)
		__attribute__((warn_unused_result));
```



## Docker

Installare le utility
```
iproute2
iputils-ping
```

Per testare l'mtu utilizzare il seguente comando, nell'mtu possiamo mettere un messaggio, se questo rientra nell'mtu allora viene inviato. Se invece quello che si vuole inviare eccede la dimensione il messaggio non viene inviato e ritorna un messaggio di errore

```
ping -M do -s <mtu> <ip>
```

## TC

Per modificare i parametri dell'interfaccia di rete possiamo utilizzare i seguenti comandi, uno modifica la packet loss mentre l'altro modifica il delay.

```
tc qdisc add dev <interface> root netem loss <percentage%>
tc qdisc add dev <interface> root netem delay <ms> 
```

Per rimuovere le impostazioni dall'interfaccia utilizziamo il seguente comando:
```
sudo tc qdisc del dev eth0 root
```
